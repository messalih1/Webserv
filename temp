    char data[len];
    bzero(data, len);
    bytes_received = recv(client_socket, &data, len, 0);
    
    if (bytes_received == -1) 
        return -1;
    else if (bytes_received == 0) 
    {
        cout << "Client disconnected\n";
        EV_SET(&kev, client_socket, EVFILT_READ, EV_DELETE, 0, 0, NULL);
        kevent(kq, &kev, 1, NULL, 0, NULL); 
        close(client_socket);
        return 1;
    }
     

    int j = 0; 
    while (j < bytes_received)
    {
        buffer.push_back(data[j]);
        j++;
    }
      
    // total_bytes_received += len;
    
    // pos = 0;
    // while (buffer[pos])
    // {
    //     if(buffer[pos] == '\r' && buffer[pos + 1] == '\n')
    //     {
    //         pos += 2;
    //         if(buffer[pos] == '\r' && buffer[pos + 1] == '\n' )
    //         {
    //             headerOfRequest = buffer.substr(0,pos);
    //             pos = headerOfRequest.find("Content-Length");
    //             if(pos != -1)
    //             {
    //                 ContentLength = atoi(headerOfRequest.substr(pos + 16,headerOfRequest.size()).c_str());
    //                 // return 1;
    //             }
    //             // return 2;
    //         }
    //         --pos;
    //     }
    //     pos++;
    // }



 // while (total_bytes_received < len) 
    // {
    //     char data[BUFFER_SIZE];
    //     bzero(data, BUFFER_SIZE);
    //     bytes_received = recv(client_socket, &data, BUFFER_SIZE, 0);
        
    //     if (bytes_received == -1) 
    //         return -1;
         
    //     total_bytes_received += bytes_received; // 5
        int j = 0; 
        while (j < bytes_received)
        {
            buffer.push_back(data[j]);
            j++;
        }
        int pos = 0;
        while (buffer[pos] && flag == 0)
        {
            if(buffer[pos] == '\r' && buffer[pos + 1] == '\n')
            {
                pos += 2;
                if(buffer[pos] == '\r' && buffer[pos + 1] == '\n' )
                {
                    headerOfRequest = buffer.substr(0,pos);
                    pos = headerOfRequest.find("Content-Length");
                    if(pos != -1)
                    {
                        ContentLength = atoi(headerOfRequest.substr(pos + 16,headerOfRequest.size()).c_str());
                        flag = 1;
                        i = headerOfRequest.size();
                        break;
                    }
                    // return 2;
                }
                --pos;
            }
            pos++;
        }
    }


44793994

44794246



GET / HTTP/1.1
User-Agent: PostmanRuntime/7.31.0
Accept: */*
Postman-Token: 491ceba3-cc23-4207-8322-ae3bba33eba9
Host: 127.0.0.1:8081
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Content-Length: 2568499
Content-Type: image/jpeg


HTTP/1.1

Host:
127.0.0.1:8081
Connection:
keep-alive
Cache-Control:
max-age=0
sec-ch-ua:
"Chromium";v="110",
"Not
A(Brand";v="24",
"Google
Chrome";v="110"
sec-ch-ua-mobile:
?0
sec-ch-ua-platform:
"macOS"
Upgrade-Insecure-Requests:
1
User-Agent:
Mozilla/5.0
(Macintosh;
Intel
Mac
OS
X
10_15_7)
AppleWebKit/537.36
(KHTML,
like
Gecko)
Chrome/110.0.0.0
Safari/537.36
Accept:
text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site:
none
Sec-Fetch-Mode:
navigate
Sec-Fetch-User:
?1
Sec-Fetch-Dest:
document
Accept-Encoding:
gzip,
deflate,
br
Accept-Language:
en-GB,en-US;q=0.9,en;q=0.8,ar;q=0.7,fr;q=0.6




int clients_obj::getHeaderLine()
{
    char *header = strtok((char*)(headerOfRequest.data()),"\r\n");
     int len = strlen(header);

    char *tmp = strtok(header," ");
    if(strcmp(tmp,"GET") != 0 && strcmp(tmp,"POST") != 0 && strcmp(tmp,"DELET") != 0)
        return -1;
    tmp = strtok(NULL," ");
    if(tmp[0] != '/')
        return -1;
    tmp = strtok(NULL," ");
    if(strcmp(tmp,"HTTP/1.1") != 0)
        return -1;
    
    // while (header != NULL )
    // { 
    //     if (strcmp(header,"Host:") != 0 && strcmp(header,"Connection:") != 0 && strcmp(header,"Cache-Control:") != 0 && strcmp(header,"sec-ch-ua:") != 0 &&
    //     strcmp(header,"sec-ch-ua-mobile:") != 0 &&strcmp(header,"sec-ch-ua-platform:") != 0 && strcmp(header,"Upgrade-Insecure-Requests:") != 0 && 
    //     strcmp(header,"User-Agent:") != 0 && strcmp(header,"Accept:") != 0 && strcmp(header,"Sec-Fetch-Site:")!= 0 && strcmp(header,"Sec-Fetch-Mode:") != 0 && 
    //     strcmp(header,"Sec-Fetch-User:") != 0 && strcmp(header,"Sec-Fetch-Dest:")!= 0 && strcmp(header,"Accept-Encoding:") != 0 && strcmp(header,"Accept-Language:") != 0 &&
    //     strcmp(header,"Postman-header:") != 0  && strcmp(header,"Content-Type:") != 0) return -1;
         
    //     header = strtok(NULL, " ");
    // }
    return len;
}

 // use malloc

int clients_obj::checkToken(char *token)
{
    int j = 0;
    int k = 0;
    string sub1 = "";
    string sub2 = "";
    while (token[i])
    {
        if(token[i] == ':')
        {
            while (k < i)
                sub1.push_back(token[k++]);
            i++;
            while (token[i])
                sub2.push_back(token[i++]);
            break;
        }
        i++;
    }
     
    cout << sub1 << endl;
    cout << sub2 << endl;
    return 1;
}

int clients_obj::checkbody_(int r)
{
    char *token = strtok(&headerOfRequest[r + 2],"\r\n");
    
    
    while (token != NULL)
    {
        if(checkToken(token) == -1)
            return -1;
        
        token = strtok(NULL,"\r\n");
    }
    
    return 1;
}
int clients_obj::checkHeaderOfreq()
{
    int returnfunc;

    returnfunc = getHeaderLine();
     
    if(returnfunc <= 0)
        return -1;
    
    if(checkbody_(returnfunc) == -1)
        return -1;

    // while (header != NULL )
    // { 
        // if (strcmp(header,"Host:") != 0 && strcmp(header,"Connection:") != 0 && strcmp(header,"Cache-Control:") != 0 && strcmp(header,"sec-ch-ua:") != 0 &&
        // strcmp(header,"sec-ch-ua-mobile:") != 0 &&strcmp(header,"sec-ch-ua-platform:") != 0 && strcmp(header,"Upgrade-Insecure-Requests:") != 0 && 
        // strcmp(header,"User-Agent:") != 0 && strcmp(header,"Accept:") != 0 && strcmp(header,"Sec-Fetch-Site:")!= 0 && strcmp(header,"Sec-Fetch-Mode:") != 0 && 
        // strcmp(header,"Sec-Fetch-User:") != 0 && strcmp(header,"Sec-Fetch-Dest:")!= 0 && strcmp(header,"Accept-Encoding:") != 0 && strcmp(header,"Accept-Language:") != 0 &&
        // strcmp(header,"Postman-header:") != 0  && strcmp(header,"Content-Type:") != 0) return -1;
    //      cout << header << endl;
    //     header = strtok(NULL, " ");
    // }
 

    return 1;
}


if(rtn > 0 && flag == 1) // if has content lenght
    {
        if(flag_ == 0) // to enter here one time
        {
            rtn = headerOfRequest.find("mp4");
            if(rtn != -1)
                MyFile.open(file.append(index).append(".mp4"));
            rtn = headerOfRequest.find("jpeg");
            if(rtn != -1)
                MyFile.open("file.jpeg");
            rtn = headerOfRequest.find("pdf");
            if(rtn != -1)
                MyFile.open("file.pdf");
            flag_ = 1;
        }
        i += len;
        if(i >= ContentLength )// finish recivng
        {
            MyFile << buffer.substr(headerOfRequest.size() + 2,ContentLength);
            // cout << "recive from client: "  << client_socket << endl;
            MyFile.close();
        }
    }
    else if(rtn == 0)
    {
        // check header line and headers
         // withou budy
    }
    else
        return -2;
     
while (buffer[pos] && flag == 0)// for entring one time
    {
        if(buffer[pos] == '\r' && buffer[pos + 1] == '\n')
        {
            pos += 2;
            if(buffer[pos] == '\r' && buffer[pos + 1] == '\n' )
            {
                headerOfRequest = buffer.substr(0,pos);
                // check header line and headers | send request from nc
                // send custom request to server
                if(checkHeaderOfreq_() == -1)
                    return -1;
                
                pos = headerOfRequest.find("Content-Length"); // return from the checkHeaderOfreq() the content lenght
                if(pos != -1)
                {
                    ContentLength = ft_atoi(headerOfRequest.substr(pos + 16,headerOfRequest.size()).c_str());
                    flag = 1;
                    i = headerOfRequest.size();
                    return  ContentLength;
                }
                else
                {
                    // without body
                    flag = 2;
                    return 0;
                }
            }
            --pos;
        }
        pos++;
    }
    
    if(flag == 1)
        return 1;
    else if(flag == 2)
        return 0;
    else
        return -1;



- slice header of request.
- if found content lenght return it






echo -e "GET / HTTP/1.1\r\nHost: www.example.com\r\n\r\n" | nc www.example.com 80


GET / HTTP/1.1














while (str[i])
    {
        j = i;
        while (str[i] && str[i] != ':')
            i++;
        i++;
        temp = ft_substr(str.data(),j,i);
        if( strcmp("Host:",temp) != 0 && strcmp("User-Agent:",temp) != 0 && strcmp("Accept:",temp) != 0 && strcmp("Accept-Language:",temp) != 0 && strcmp("Accept-Encoding:",temp) != 0 && strcmp("Authorization:",temp) != 0 && strcmp("Cache-Control:",temp) != 0 && 
        strcmp("Connection:",temp) != 0 && strcmp("Content-Length:",temp) != 0 && strcmp("Content-Type:",temp) != 0   && strcmp("sec-ch-ua:",temp) != 0 && strcmp("sec-ch-ua-mobile:",temp) != 0 && strcmp("sec-ch-ua-platform:",temp) != 0 &&
        strcmp("Upgrade-Insecure-Requests:",temp) != 0 && strcmp("Sec-Fetch-Site:",temp) != 0 && strcmp("Sec-Fetch-Mode:",temp) != 0 && strcmp("Sec-Fetch-User:",temp) != 0 && strcmp("Sec-Fetch-Dest:",temp) != 0) 
        {
            if(strcmp("\r\n",temp) == 0)
            {
                free(temp);
                return 1;    
            }
            else
            {
                free(temp);
                return -1;
            }
        }
        i++;
        j = i;
        while (str[i] && str[i] != '\n')
            i++;
        temp = ft_substr(str.data(),j,i );
        if(strlen(temp) < 2 ||  temp[strlen(temp) - 1] != '\r')// && temp[strlen(temp) + 1] != '\n'))
        {
            free(temp);
            return -1;
        }
        free(temp);
        i++;
    }



    while (token[i] && token[i] != ' ')
        i++;
    
    temp = ft_substr(token,j,i);
     
    if( strcmp("Host:",temp) != 0 && strcmp("User-Agent:",temp) != 0 && strcmp("Accept:",temp) != 0 && strcmp("Accept-Language:",temp) != 0 && strcmp("Accept-Encoding:",temp) != 0 && strcmp("Authorization:",temp) != 0 && strcmp("Cache-Control:",temp) != 0 && 
    strcmp("Connection:",temp) != 0 && strcmp("Content-Length:",temp) != 0 && strcmp("Content-Type:",temp) != 0   && strcmp("sec-ch-ua:",temp) != 0 && strcmp("sec-ch-ua-mobile:",temp) != 0 && strcmp("sec-ch-ua-platform:",temp) != 0 &&
    strcmp("Upgrade-Insecure-Requests:",temp) != 0 && strcmp("Sec-Fetch-Site:",temp) != 0 && strcmp("Sec-Fetch-Mode:",temp) != 0 && strcmp("Sec-Fetch-User:",temp) != 0 && strcmp("Sec-Fetch-Dest:",temp) != 0) 
    {
        free(temp);
        return -1;
    }
    free(temp);
    
    temp = ft_substr(token,i + 1,strlen(token - j));
     
    if(strlen(temp) == 0 || temp[strlen(temp) - 1] != '\r')
    {
        free(temp);
        return -1;
    }
    free(temp);




    boundary=--------------------------546396952315283955169235
Content-Length: 276

----------------------------546396952315283955169235
Content-Disposition: form-data; name="name"

test
----------------------------546396952315283955169235
Content-Disposition: form-data; name="address"

capital
----------------------------546396952315283955169235--





17 => len of request body
6\r\n
Hello,
6\r\n
world!
0\r\n
\r\n
0\r\n


 

7\r\n
abc\n
dfe\r\n
0



2300044

2300023
// trnsfere encoding




















52
13
10
97
10
10
98
13
10
48
13
10
13
10